generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Client {
  id        Int       @id @default(autoincrement())
  name      String
  phone     String    @unique
  email     String?
  tgUserId  String?   @unique
  vehicles  Vehicle[]
  orders    Order[]
  users     User[]
  loyaltyPoints Int   @default(0)
  rating    Float?
  achievements UserAchievement[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@map("clients")
}

enum Role {
  admin
  service_manager
  dispatcher
  mechanic
  customer
}

model User {
  id            Int       @id @default(autoincrement())
  email         String?   @unique
  phone         String?   @unique
  passwordHash  String
  name          String?
  walletAddress String?   @unique
  role          Role      @default(customer)
  clientId      Int?
  client        Client?   @relation(fields: [clientId], references: [id])
  tokenVersion  Int       @default(0)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  auditEvents   AuditEvent[]
}

model Vehicle {
  id        Int     @id @default(autoincrement())
  clientId  Int
  vin       String? @unique
  plate     String  @unique
  make      String?
  model     String?
  year      Int?
  mileage   Int?
  nftTokenId String? @unique // NFT passport token ID
  client    Client  @relation(fields: [clientId], references: [id])
  orders    Order[]
  maintenanceHistory MaintenanceRecord[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("vehicles")
}

enum OrderStatus {
  NEW
  TRIAGE
  QUOTE
  APPROVED
  SCHEDULED
  INSERVICE
  READY
  DELIVERED
  CLOSED
  CANCELLED
}

model Order {
  id          Int         @id @default(autoincrement())
  clientId    Int
  vehicleId   Int
  status      OrderStatus @default(NEW)
  category    String      // engine, transmission, suspension, electrical, etc.
  description String?
  channel     String      @default("web") // web, mobile, telegram
  priority    String      @default("normal") // low, normal, high, urgent
  locations   OrderLocation[]
  estimate    Estimate?
  payments    Payment[]
  tow         TowRequest?
  offers      InsuranceOffer[]
  attachments Attachment[]
  timeline    OrderTimeline[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  client      Client      @relation(fields: [clientId], references: [id])
  vehicle     Vehicle     @relation(fields: [vehicleId], references: [id])

  @@index([clientId])
  @@index([status])

  @@map("orders")
}

model OrderLocation {
  id       Int    @id @default(autoincrement())
  orderId  Int
  kind     String // pickup, dropoff
  lat      Float
  lng      Float
  address  String?
  notes    String?
  order    Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@map("order_locations")
}

model Estimate {
  id        Int      @id @default(autoincrement())
  orderId   Int      @unique
  itemsJson Json     // parts list with prices
  laborJson Json     // labor costs breakdown
  total     Decimal  @db.Decimal(12,2)
  currency  String   @default("UAH")
  validUntil DateTime
  approved  Boolean  @default(false)
  approvedAt DateTime?
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@map("estimates")
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
}

enum PaymentMethod {
  CARD
  BANK_TRANSFER
  CRYPTO
  CASH
}

model Payment {
  id         Int           @id @default(autoincrement())
  orderId    Int
  amount     Decimal       @db.Decimal(12,2)
  method     PaymentMethod
  status     PaymentStatus @default(PENDING)
  invoiceUrl String?
  receiptUrl String?
  txHash     String?       // blockchain transaction hash
  provider   String?       // liqpay, stripe, etc.
  providerId String?       // external payment ID
  createdAt  DateTime      @default(now())
  completedAt DateTime?
  order      Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@map("payments")
  @@index([orderId])
  @@index([status])
}

enum TowStatus {
  REQUESTED
  ASSIGNED
  ENROUTE
  ARRIVED
  LOADING
  INTRANSIT
  DELIVERED
  COMPLETED
  CANCELLED
}

model TowRequest {
  id          Int       @id @default(autoincrement())
  orderId     Int       @unique
  status      TowStatus @default(REQUESTED)
  distanceKm  Float?
  etaMinutes  Int?
  price       Decimal?  @db.Decimal(12,2)
  partnerId   Int?      // tow truck company
  driverName  String?
  driverPhone String?
  vehicleInfo String?   // tow truck details
  trackingUrl String?
  order       Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("tow_requests")
}

enum InsuranceOfferStatus {
  OFFERED
  ACCEPTED
  DECLINED
  EXPIRED
  ACTIVE
  CLAIMED
}

model InsuranceOffer {
  id          Int                   @id @default(autoincrement())
  orderId     Int
  code        String                // KASKO_GLASS, BREAKDOWN_EXTENDED, etc.
  title       String
  description String?
  price       Decimal               @db.Decimal(12,2)
  duration    Int?                  // months
  coverage    Json?                 // coverage details
  status      InsuranceOfferStatus  @default(OFFERED)
  validUntil  DateTime?
  activatedAt DateTime?
  expiresAt   DateTime?
  order       Order                 @relation(fields: [orderId], references: [id], onDelete: Cascade)
  createdAt   DateTime              @default(now())

  @@map("insurance_offers")
}

enum AttachmentType {
  PHOTO
  VIDEO
  DOCUMENT
  AUDIO
}

model Attachment {
  id        Int            @id @default(autoincrement())
  orderId   Int
  type      AttachmentType
  url       String
  filename  String?
  size      Int?           // bytes
  meta      Json?          // metadata (dimensions, duration, etc.)
  createdAt DateTime       @default(now())
  order     Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  // new fields (extended)
  objectKey  String?        @db.Text
  contentType String?
  status      AttachmentStatus @default(pending)
  removedAt   DateTime?
  createdBy   Int?

  @@index([orderId])
  @@index([status])

  @@map("attachments")
}

// Webhook events to ensure idempotent processing
model WebhookEvent {
  id         String   @id
  type       String
  receivedAt DateTime @default(now())
  payload    Json?
  handled    Boolean  @default(false)

  @@map("webhook_events")
}

enum AttachmentStatus {
  pending
  ready
  removed
}

model OrderTimeline {
  id        Int      @id @default(autoincrement())
  orderId   Int
  event     String   // status_changed, payment_received, etc.
  details   Json?
  userId    String?  // who performed the action
  createdAt DateTime @default(now())
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@map("order_timeline")
}

model MaintenanceRecord {
  id          Int      @id @default(autoincrement())
  vehicleId   Int
  type        String   // routine, repair, inspection
  description String
  mileage     Int?
  cost        Decimal? @db.Decimal(12,2)
  performedAt DateTime
  performedBy String?  // service center
  vehicle     Vehicle  @relation(fields: [vehicleId], references: [id])
  createdAt   DateTime @default(now())

  @@map("maintenance_records")
}

// Gamification models
model Achievement {
  id          Int      @id @default(autoincrement())
  code        String   @unique
  title       String
  description String
  icon        String?
  points      Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  userAchievements UserAchievement[]

  @@map("achievements")
}

model UserAchievement {
  id            Int         @id @default(autoincrement())
  clientId      Int
  achievementId Int
  earnedAt      DateTime    @default(now())
  client        Client      @relation(fields: [clientId], references: [id])
  achievement   Achievement @relation(fields: [achievementId], references: [id])

  @@unique([clientId, achievementId])
  @@map("user_achievements")
}

// Nonces for wallet signature-based auth
model WalletNonce {
  address   String  @id
  nonce     String
  createdAt DateTime @default(now())

  @@map("wallet_nonces")
}

// Central audit/event log for admin history
model AuditEvent {
  id        Int      @id @default(autoincrement())
  type      String
  payload   Json?
  userId    Int?
  user      User?    @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())

  @@index([userId])
  @@map("audit_events")
}

